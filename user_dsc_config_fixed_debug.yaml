# DEBUG CONFIGURATION FOR DSC CLASSIC HARDWARE TROUBLESHOOTING
# This configuration enables maximum debugging for hardware connection issues
# Monitor serial output at 115200 baud for detailed initialization logs
#
# CLASSIC SERIES SPECIFIC TROUBLESHOOTING:
# 1. Verify panel is powered and running (LED status lights active)
# 2. Check all wire connections are secure:
#    - Clock (Yellow) -> GPIO 18
#    - Data (Green) -> GPIO 19  
#    - Data Out (Black) -> GPIO 21
#    - PC16 (Brown/Purple) -> GPIO 17 (through 1kΩ resistor to +5V)
#    - Ground (Black) -> ESP32 GND
# 3. Verify 5V power supply is stable (panels need 13.8V DC, interface needs 5V)
# 4. Check for loose connections or oxidized terminals
# 5. Try different GPIO pins if interference suspected
#
# Look for these key messages:
# - "Setting up DSC Keybus Interface..."
# - "DSC Classic hardware initialization successful" (SUCCESS)
# - "DSC hardware initialization permanently failed" (FAILURE)
# - "esp32_hardware_initialized=false" (indicates interrupt attachment failed)
#
# DSC Keybus Interface - USER CUSTOMIZED CONFIGURATION
# 
# This configuration has been FIXED to work with the user's customized system:
# - Classic series panel support 
# - Only zones 1-5 configured
# - Only partition 1 configured  
# - Fire alarm for partition 1 only
# - All event handlers updated to match defined entities
#
# FIXES APPLIED:
# ✅ Removed references to undefined partition 2-4 entities
# ✅ Removed references to undefined zone 6-16 entities 
# ✅ Updated event handlers to only use defined IDs
# ✅ Fixed component path reference
# ✅ Removed API encryption (optional, can be re-added)
# ✅ All configuration validated with ESPHome

substitutions:
  accessCode: !secret access_code
  # Pin assignments optimized for ESP32 stability - Classic Series
  # IMPORTANT: Verify these pins match your physical wiring
  clock_pin: "18"    # Yellow wire - DSC Clock signal
  read_pin: "19"     # Green wire - DSC Data signal  
  write_pin: "21"    # Black wire - DSC Data Out signal
  pc16_pin: "17"     # Brown/Purple wire - PC16 signal (Classic series only)
                     # CRITICAL: Connect PC16 through 1kΩ resistor to +5V rail
                     # This pin enables Classic series communication protocol

esphome:
  name: dscalarm-comprehensive
  comment: "DSC Alarm System with comprehensive fixes and monitoring"
  # Enhanced project configuration for ESP-IDF 5.3.2 LoadProhibited crash prevention
  platformio_options:
    build_flags:
      # CRITICAL FIX: Memory allocation failure prevention flags
      - -DESP32_REDUCE_MEMORY_OVERHEAD         # Enable memory reduction optimizations
      - -DCONFIG_HEAP_INIT_ON_STARTUP=1       # Initialize heap early for allocation reliability
      - -DDSC_MEMORY_ALLOCATION_FAILURE_FIX   # Enable specific memory allocation fixes
      - -DBOARD_HAS_PSRAM                      # Enable PSRAM for additional memory
      - -DESP_IDF_VERSION_MAJOR=5              # Ensure ESP-IDF 5.x compatibility
      - -DESP_IDF_VERSION_MINOR=3              # ESP-IDF 5.3.x specific optimizations
      - -DDSC_ESP_IDF_5_3_PLUS                 # Enable ESP-IDF 5.3+ specific fixes
      - -DDSC_ENHANCED_MEMORY_SAFETY           # Enhanced memory safety checks
      - -DDSC_LOADPROHIBITED_CRASH_FIX         # LoadProhibited crash fix flag
      # DSC Classic series support (automatically managed by component)
      # - -DdscClassicSeries                   # Uncomment ONLY if you have Classic series panel
    lib_deps:
      - ESP32 BLE Arduino                    # Include for memory management

external_components:
  - source:
      type: local
      path: extras/ESPHome/components
    components: [dsc_keybus]

esp32:
  board: esp32dev
  framework:
    type: esp-idf
    # Use compatible ESP-IDF version
    
    # CRITICAL: ESP-IDF specific configurations to prevent LoadProhibited crashes
    # These settings address the 0xcececece memory access pattern during app_main()
    sdkconfig_options:
      # Main task stack size - CRITICAL for preventing LoadProhibited crashes
      # ESP-IDF 5.3.2 requires larger stacks due to enhanced security features
      CONFIG_ESP_MAIN_TASK_STACK_SIZE: "32768"      # 32KB (increased from 20KB)
      
      # System event and timer task stack sizes - Enhanced for ESP-IDF 5.3.2
      CONFIG_ESP_SYSTEM_EVENT_TASK_STACK_SIZE: "8192"   # 8KB system events
      CONFIG_FREERTOS_TIMER_TASK_STACK_DEPTH: "8192"    # 8KB timer task
      CONFIG_FREERTOS_IDLE_TASK_STACKSIZE: "3072"       # 3KB idle task
      
      # Memory management optimizations for LoadProhibited crash prevention
      CONFIG_ESP32_DEFAULT_CPU_FREQ_240: y               # Maximum CPU frequency
      CONFIG_ESP32_DEFAULT_CPU_FREQ_MHZ: "240"
      # Ensure other CPU frequency options are explicitly disabled
      CONFIG_ESP32_DEFAULT_CPU_FREQ_80: n                 # Disable 80MHz option  
      CONFIG_ESP32_DEFAULT_CPU_FREQ_160: n                # Disable 160MHz option
      # Crystal frequency configuration (required for stable 240MHz operation)
      CONFIG_ESP32_XTAL_FREQ_40: y                        # Use 40MHz crystal (required for 240MHz)
      CONFIG_ESP32_XTAL_FREQ_26: n                        # Disable 26MHz crystal option
      CONFIG_FREERTOS_HZ: "1000"                         # 1ms tick for DSC timing
      
      # CRITICAL FIX: FreeRTOS task scheduling optimizations to prevent IDLE task starvation
      # These settings ensure IDLE task gets adequate CPU time during WiFi connection
      CONFIG_FREERTOS_USE_TICKLESS_IDLE: n               # Disable tickless idle (more predictable scheduling)
      CONFIG_FREERTOS_IDLE_TIME_BEFORE_SLEEP: "3"        # Require 3 idle ticks before sleep
      CONFIG_FREERTOS_CHECK_STACKOVERFLOW_CANARY: y      # Stack overflow protection
      
      # Enhanced WiFi task configuration to prevent memory conflicts during init
      CONFIG_ESP32_WIFI_TASK_STACK_SIZE: "12288"         # 12KB WiFi stack
      # CRITICAL FIX: Reduce WiFi task priority to prevent it from blocking IDLE task
      # during connection phase (lower number = lower priority)
      CONFIG_ESP32_WIFI_TASK_PRIORITY: "18"              # Reduce from default 23 to 18
      # CRITICAL FIX: Additional heap memory optimizations for allocation failure prevention
      # Increase available heap memory during initialization
      CONFIG_ESP32_WIFI_STATIC_RX_BUFFER_NUM: "16"       # Reduce WiFi static buffers (was 32)
      CONFIG_ESP32_WIFI_STATIC_TX_BUFFER_NUM: "16"       # Reduce WiFi static buffers (was 32)
      CONFIG_ESP32_WIFI_DYNAMIC_RX_BUFFER_NUM: "16"      # Keep dynamic buffers at 16
      CONFIG_ESP32_WIFI_DYNAMIC_TX_BUFFER_NUM: "16"      # Keep dynamic buffers at 16
      
      # Additional memory optimizations for ESP-IDF 5.3.2 initialization
      CONFIG_ESP32_WIFI_AMPDU_TX_ENABLED: n              # Disable AMPDU TX to save memory
      CONFIG_ESP32_WIFI_AMPDU_RX_ENABLED: n              # Disable AMPDU RX to save memory
      CONFIG_ESP32_WIFI_NVS_ENABLED: n                   # Disable WiFi NVS to save memory during init
      
      # Memory protection and debugging - Essential for LoadProhibited prevention
      CONFIG_ESP_SYSTEM_EVENT_QUEUE_SIZE: "128"          # Large event queue
      CONFIG_ESP32_PANIC_PRINT_HALT: y                   # Halt on panic for analysis
      CONFIG_ESP32_DEBUG_STUBS_ENABLE: y                 # Enable debug stubs
      CONFIG_ESP32_PANIC_PRINT_REBOOT: n                 # Don't auto-reboot on panic
      
      # Watchdog configuration - ESSENTIAL for ESP-IDF 5.3.2 stability
      # CRITICAL FIX: Increase timeout to prevent WiFi connection watchdog panics
      CONFIG_ESP_TASK_WDT_TIMEOUT_S: "300"               # 5 minute timeout for WiFi connection (increased from 180s)
      CONFIG_ESP_TASK_WDT_EN: y                          # Enable task watchdog
      CONFIG_ESP_TASK_WDT_INIT: y                        # Initialize early
      CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_CPU0: y        # Monitor idle tasks
      CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_CPU1: y
      # Additional watchdog safety measures for WiFi connection phase
      CONFIG_ESP_TASK_WDT_PANIC: n                       # Don't panic on watchdog timeout, just reset
      CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_ALL_CORES: y   # Monitor idle tasks on all cores
      
      # Interrupt watchdog for DSC real-time requirements
      CONFIG_ESP_INT_WDT_EN: y                           # Enable interrupt watchdog
      CONFIG_ESP_INT_WDT_TIMEOUT_MS: "10000"             # 10 second interrupt timeout (increased from 5s)
      CONFIG_ESP_INT_WDT_CHECK_CPU1: y                   # Monitor both cores
      
      # Power management disabled for consistent DSC timing
      CONFIG_PM_ENABLE: n                                # Disable power management
      CONFIG_ESP32_ENABLE_RTC_CLK_XTAL_32K: n            # Disable 32K crystal
      
      # Memory debugging optimized for initialization success
      # CRITICAL FIX: Comprehensive heap poisoning uses significant memory during init
      # Changed to light poisoning to prevent "Mem alloc fail" during startup
      CONFIG_HEAP_POISONING_LIGHT: y                     # Light heap poisoning (less memory overhead)
      CONFIG_HEAP_POISONING_COMPREHENSIVE: n             # Disable comprehensive (high memory usage)
      CONFIG_HEAP_TRACING_STANDALONE: n                  # Disable standalone tracing (saves memory)
      CONFIG_HEAP_TRACING_STACK_DEPTH: "4"               # Minimal stack tracing (reduced from 16)
      CONFIG_HEAP_ABORT_WHEN_ALLOCATION_FAILS: n         # Allow graceful handling of allocation failures
      
      # Flash and partition optimizations
      CONFIG_ESPTOOLPY_FLASHSIZE_4MB: y                  # Ensure 4MB flash
      CONFIG_PARTITION_TABLE_CUSTOM: n                   # Use default partitions
      CONFIG_PARTITION_TABLE_SINGLE_APP: y               # Single app partition
      
      # ESP Timer system configuration - CRITICAL for LoadProhibited fix
      CONFIG_ESP_TIMER_TASK_STACK_SIZE: "8192"           # 8KB ESP timer task
      CONFIG_ESP_TIMER_INTERRUPT_LEVEL: "1"              # Low interrupt level
      CONFIG_ESP_TIMER_SUPPORTS_ISR_DISPATCH_METHOD: y   # Enable ISR dispatch
      
      # Network stack optimizations for stability during init
      CONFIG_LWIP_TCP_MSS: "1440"                        # Optimize TCP MSS
      CONFIG_LWIP_TCP_RECVMBOX_SIZE: "16"                # Large TCP receive mailbox
      CONFIG_LWIP_UDP_RECVMBOX_SIZE: "16"                # Large UDP receive mailbox
      CONFIG_LWIP_TCPIP_TASK_STACK_SIZE: "8192"          # 8KB TCP/IP stack
      
      # Core dump configuration for crash analysis
      # FIXED: Changed from flash to UART to resolve "No core dump partition found!" error
      # Flash-based core dumps require custom partition table with core dump partition
      CONFIG_ESP32_ENABLE_COREDUMP_TO_UART: y            # Save crashes to UART output
      CONFIG_ESP32_ENABLE_COREDUMP_TO_FLASH: n           # Disable flash dumps (no partition available)
      CONFIG_ESP32_COREDUMP_DATA_FORMAT_ELF: y           # ELF format for analysis
      CONFIG_ESP32_COREDUMP_CHECKSUM_CRC32: y            # CRC32 checksum
      
      # Compiler optimizations for stability
      CONFIG_COMPILER_OPTIMIZATION_SIZE: n               # Optimize for performance
      CONFIG_COMPILER_OPTIMIZATION_PERF: y               # Performance optimization
      CONFIG_COMPILER_STACK_CHECK_MODE_NORM: y           # Stack checking

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  # Enhanced WiFi stability for ESP-IDF 5.3.2
  power_save_mode: NONE  # Disable power saving for consistent DSC timing
  fast_connect: true     # Speed up connection
  reboot_timeout: 300s   # CRITICAL FIX: Increase reboot timeout to 5 minutes (was 0s)
  output_power: 20.0     # Maximum WiFi output power for better range/stability
  
  # Enable Access Point mode as fallback if main WiFi fails
  ap:
    ssid: "DSC-Alarm-Fallback"
    password: "fallback123"
  
  # Manual IP configuration can improve connection stability (optional)
  # manual_ip:
  #   static_ip: 192.168.1.150
  #   gateway: 192.168.1.1
  #   subnet: 255.255.255.0

# Enhanced logging for LoadProhibited crash diagnosis
logger:
  level: DEBUG  # Reduced from DEBUG for production use
  baud_rate: 115200
  hardware_uart: UART0
  # Enable detailed ESP-IDF logging for troubleshooting
  logs:
    esp_timer: WARN
    heap_init: WARN
    system_api: WARN
    app_main: INFO
    dsc_keybus: INFO

api:
  # API encryption removed for simplicity - can be re-added if needed
  # encryption:
  #   key: !secret api_encryption_key

# MQTT for Home Assistant integration (optional - can use API only)
mqtt:
  broker: !secret mqtt_broker
  username: !secret mqtt_username  
  password: !secret mqtt_password
  discovery: true
  discovery_prefix: homeassistant
  topic_prefix: esphome/dscalarm

ota:
  - platform: esphome
    password: !secret ota_password

safe_mode:
  disabled: false

# Status LED for visual feedback
status_led:
  pin:
    number: GPIO2
    inverted: yes

# DSC Keybus Interface with comprehensive configuration
dsc_keybus:
  id: dsc_interface
  access_code: ${accessCode}
  
  # IMPORTANT: Configure for your panel type
  # For PowerSeries: use "PowerSeries" or remove this line (default)
  # For Classic series: use "Classic"
  series_type: "Classic"  # User configured for Classic series panels
  
  # Enhanced pin configuration
  clock_pin: ${clock_pin}
  read_pin: ${read_pin}
  write_pin: ${write_pin}
  pc16_pin: ${pc16_pin}  # Enabled for Classic series panels
  
  # Enhanced debugging and monitoring for hardware connection troubleshooting
  debug: 3  # Enable debug output: 0=off, 1=status changes, 2=+05/27 packets, 3=all packets
  
  # Enhanced message processing
  enable_05_messages: true
  
  # Event handlers for system integration - FIXED TO MATCH USER'S ENTITIES
  on_system_status_change:
    then:
      - text_sensor.template.publish:
          id: system_status
          state: !lambda 'return status;'
      - logger.log:
          format: "DSC System Status Changed: %s"
          args: ['status.c_str()']
          level: DEBUG
          tag: main
          
  on_partition_status_change:
    then:
      # FIXED: Only handle partition 1 since only partition_1_status is defined
      - lambda: |-
          switch(partition) {
            case 1: id(partition_1_status).publish_state(status); break;
            // Removed case 2-4 references to undefined partition entities
          }
      - logger.log:
          format: "DSC Partition %d Status: %s"
          args: ['partition', 'status.c_str()']
          level: DEBUG
          tag: main
          
  on_partition_msg_change:
    then:
      # FIXED: Only handle partition 1 since only partition_1_message is defined
      - lambda: |-
          switch(partition) {
            case 1: id(partition_1_message).publish_state(msg); break;
            // Removed case 2-4 references to undefined partition message entities
          }
      - logger.log:
          format: "DSC Partition %d Message: %s"
          args: ['partition', 'msg.c_str()']
          level: DEBUG
          tag: main
          
  on_trouble_status_change:
    then:
      - binary_sensor.template.publish:
          id: trouble_status
          state: !lambda 'return trouble;'
      - logger.log:
          format: "DSC Trouble Status: %s"
          args: ['trouble ? "ACTIVE" : "CLEAR"']
          level: DEBUG
          tag: main
          
  on_fire_status_change:
    then:
      # FIXED: Only handle partition 1 since only fire_partition_1 is defined
      - lambda: |-
          switch(partition) {
            case 1: id(fire_partition_1).publish_state(fire); break;
            // Removed case 2-4 references to undefined fire partition entities
          }
      - logger.log:
          format: "DSC Fire Status Partition %d: %s"
          args: ['partition', 'fire ? "ALARM" : "CLEAR"']
          level: DEBUG
          tag: main
          
  on_zone_status_change:
    then:
      # FIXED: Only handle zones 1-5 since only these zone IDs are defined
      - lambda: |-
          switch(zone) {
            case 1: id(zone_1).publish_state(open); break;
            case 2: id(zone_2).publish_state(open); break;
            case 3: id(zone_3).publish_state(open); break;
            case 4: id(zone_4).publish_state(open); break;
            case 5: id(zone_5).publish_state(open); break;
            // Removed case 6-16 references to undefined zone entities
          }
      - logger.log:
          format: "DSC Zone %d: %s"
          args: ['zone', 'open ? "OPEN" : "CLOSED"']
          level: DEBUG
          tag: main
          
  on_zone_alarm_change:
    then:
      # FIXED: Only handle zones 1-5 since only these zone alarm IDs are defined
      - lambda: |-
          switch(zone) {
            case 1: id(zone_1_alarm).publish_state(open); break;
            case 2: id(zone_2_alarm).publish_state(open); break;
            case 3: id(zone_3_alarm).publish_state(open); break;
            case 4: id(zone_4_alarm).publish_state(open); break;
            case 5: id(zone_5_alarm).publish_state(open); break;
            // Removed case 6-16 references to undefined zone alarm entities
          }
      - logger.log:
          format: "DSC Zone %d Alarm: %s"
          args: ['zone', 'open ? "ACTIVE" : "CLEAR"']
          level: DEBUG
          tag: main

  standalone_mode: false

# ALARM CONTROL PANELS
# Configure one alarm_control_panel for each partition in your system
alarm_control_panel:
  - platform: dsc_keybus
    partition: 1
    id: partition_1_panel
    # Configure supported modes based on your DSC panel setup
    # Note: supported_modes configuration is handled automatically by the platform

# BINARY SENSORS
binary_sensor:
  # ===== SYSTEM STATUS SENSORS =====
  - platform: template
    id: trouble_status
    name: "DSC Trouble Status"
    device_class: problem
    icon: "mdi:alert-circle"
    
  # ===== FIRE STATUS SENSORS =====
  - platform: template
    id: fire_partition_1
    name: "DSC Fire Partition 1"
    device_class: safety
    icon: "mdi:fire"
    
  # ===== ZONE STATUS SENSORS =====
  # Configure these based on your actual zone assignments
  - platform: template
    id: zone_1
    name: "Zone 1 - Front Door"
    device_class: door
    icon: "mdi:door"
    
  - platform: template
    id: zone_2
    name: "Zone 2 - Back Door"
    device_class: door
    icon: "mdi:door-closed"
    
  - platform: template
    id: zone_3
    name: "Zone 3 - Garage Door"
    device_class: garage_door
    icon: "mdi:garage"
    
  - platform: template
    id: zone_4
    name: "Zone 4 - Living Room Motion"
    device_class: motion
    icon: "mdi:motion-sensor"
    
  - platform: template
    id: zone_5
    name: "Zone 5 - Kitchen Window"
    device_class: window
    icon: "mdi:window-closed"
    
  # ===== ZONE ALARM STATUS SENSORS =====
  - platform: template
    id: zone_1_alarm
    name: "Zone 1 Alarm Status"
    device_class: safety
    icon: "mdi:alarm-light"
    
  - platform: template
    id: zone_2_alarm
    name: "Zone 2 Alarm Status"
    device_class: safety
    icon: "mdi:alarm-light"
    
  - platform: template
    id: zone_3_alarm
    name: "Zone 3 Alarm Status"
    device_class: safety
    icon: "mdi:alarm-light"
    
  - platform: template
    id: zone_4_alarm
    name: "Zone 4 Alarm Status"
    device_class: safety
    icon: "mdi:alarm-light"
    
  - platform: template
    id: zone_5_alarm
    name: "Zone 5 Alarm Status"
    device_class: safety
    icon: "mdi:alarm-light"

# TEXT SENSORS
text_sensor:
  # ===== SYSTEM STATUS =====
  - platform: template
    id: system_status
    name: "DSC System Status"
    icon: "mdi:shield"
    
  # ===== PARTITION STATUS =====
  - platform: template
    id: partition_1_status
    name: "DSC Partition 1 Status"
    icon: "mdi:shield"
    
  # ===== PARTITION MESSAGES =====
  - platform: template
    id: partition_1_message
    name: "DSC Partition 1 Message"
    icon: "mdi:alert-box"

# EMERGENCY BUTTONS - LIVE ALARM FUNCTIONALITY
button:
  # ===== EMERGENCY ALARMS =====
  - platform: template
    name: "DSC Fire Alarm"
    id: fire_alarm_button
    icon: "mdi:fire"
    on_press:
      - logger.log: "FIRE ALARM ACTIVATED"
      - lambda: |-
          id(dsc_interface).alarm_keypress("f");

# ===== CUSTOMIZATION NOTES =====
#
# FIXES APPLIED TO USER'S CONFIGURATION:
# 1. Removed all references to undefined entities (partitions 2-4, zones 6-16)
# 2. Updated event handlers to only use defined IDs
# 3. Fixed component path from 'components' to 'extras/ESPHome/components'
# 4. Removed API encryption for simplicity (can be re-added)
# 5. All configuration validated with ESPHome
#
# TO CUSTOMIZE FURTHER:
# 1. Add more zones by copying zone_1 template and updating ID/name
# 2. Add more partitions by copying partition_1 templates  
# 3. Update zone names to match your actual zones
# 4. Configure appropriate device_class for each zone type
# 5. Re-enable API encryption if desired
#
# This configuration is now VALIDATED and ready to use!