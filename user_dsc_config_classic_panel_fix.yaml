# DSC Classic Panel Hardware Connection Fix Configuration
# 
# This configuration enables the original Arduino dscKeybusInterface timing characteristics
# for DSC Classic panels that previously worked with the Arduino library but fail with ESPHome.
#
# Key Changes from Standard ESPHome Configuration:
# 1. Enables DSC_CLASSIC_TIMING_COMPATIBILITY mode to bypass defensive ESPHome measures
# 2. Uses original interrupt timing without critical section overhead
# 3. Minimal initialization validation to maintain timing characteristics
# 4. Direct Arduino-compatible timer management
#
# Use this configuration if:
# - Your DSC Classic panel worked with the original Arduino dscKeybusInterface
# - You're getting "Hardware initialization rate limiting exceeded" errors
# - Standard ESPHome configurations fail but Arduino sketches work
#
# Expected Results:
# - Successful hardware initialization without rate limiting errors
# - No task watchdog timeouts during WiFi connection
# - Stable DSC panel communication matching Arduino library behavior

esphome:
  name: dsc-esphome-classic-fix
  friendly_name: "DSC Classic Panel (Fixed)"
  # Enhanced boot sequence for Classic panels
  on_boot:
    priority: 600
    then:
      - logger.log: "DSC Classic Panel Interface Initialized"
  platformio_options:
    build_flags:
      # CRITICAL: Enable classic timing compatibility mode
      - "-DDSC_CLASSIC_TIMING_COMPATIBILITY"
      # Classic series support with original timing
      - "-DdscClassicSeries"
      # Extended watchdog timeout for classic panel initialization
      - "-DCONFIG_ESP_TASK_WDT_TIMEOUT_S=600"
      # Reduced system timing interference
      - "-DCONFIG_ESP32_DEFAULT_CPU_FREQ_MHZ=240"
      # Memory optimization for stable classic operation
      - "-DCONFIG_SPIRAM_USE_MALLOC=1"
    build_unflags:
      # Remove aggressive optimization that affects timing
      - "-Os"
    build_src_flags:
      # Enable classic compatibility in source files
      - "-DDSC_CLASSIC_TIMING_COMPATIBILITY"
      
esp32:
  board: esp32dev
  framework:
    type: esp-idf
    version: 5.3.2
    # Classic timing requires specific ESP-IDF configuration
    sdkconfig_options:
      # Extended task watchdog for classic initialization
      CONFIG_ESP_TASK_WDT_TIMEOUT_S: "600"
      CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_CPU0: "n"
      CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_CPU1: "n"
      # Optimal CPU frequency for classic timing
      CONFIG_ESP32_DEFAULT_CPU_FREQ_MHZ_240: "y"
      CONFIG_ESP32_DEFAULT_CPU_FREQ_MHZ: "240"
      # Memory configuration for stable operation
      CONFIG_ESP32_SPIRAM_SUPPORT: "y"
      CONFIG_SPIRAM_USE_MALLOC: "y"
      # Timer precision for classic timing compatibility
      CONFIG_ESP_TIMER_TASK_PRIORITY: "22"
      CONFIG_ESP_TIMER_TASK_STACK_SIZE: "4096"

# Enable logging with appropriate level for troubleshooting
logger:
  level: INFO
  logs:
    dsc_keybus: INFO

# API configuration
api:
  encryption:
    key: !secret api_encryption_key

# OTA configuration  
ota:
  - platform: esphome
    password: !secret ota_password

# WiFi configuration with reduced priority to prevent DSC interference
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  # Reduced priority to prevent interference with DSC timing
  priority: 15.0
  # Extended connection timeout for classic panels
  connect_timeout: 60s
  # Manual IP configuration reduces DHCP timing interference
  manual_ip:
    static_ip: 192.168.1.200
    gateway: 192.168.1.1
    subnet: 255.255.255.0
    dns1: 192.168.1.1

  # Enable hotspot fallback
  ap:
    ssid: "DSC-Classic-Fallback"
    password: !secret ap_password

# Captive portal for easy configuration
captive_portal:

# DSC Keybus configuration with classic timing compatibility
external_components:
  - source: 
      type: local
      path: src
    components: [dsc_keybus]

# Classic Panel DSC Configuration
dsc_keybus:
  # Essential pin configuration for DSC Classic series
  clock_pin: GPIO18
  read_pin: GPIO19
  write_pin: GPIO21  # Optional for virtual keypad
  pc16_pin: GPIO17   # CRITICAL: PC-16 pin for Classic series - connect with 1kÎ© resistor
  
  # Classic panel timing configuration
  # These values restore original Arduino library characteristics
  hardware_detection_delay: 5000ms      # Original Arduino timing (reduced from ESPHome default)
  initialization_timeout: 30000ms       # Original Arduino timeout
  retry_delay: 2000ms                    # Original retry timing
  max_initialization_attempts: 5        # Conservative retry limit
  
  # Classic series specific configuration
  series_type: "Classic"                 # Explicitly set for DSC Classic series panels
  classic_series: true                   # Legacy compatibility flag
  
  # Enable standalone mode as fallback for connection issues
  standalone_mode: false  # Try hardware connection first
  
  # Partition configuration
  partitions: 1
  
  # Access codes for classic panels
  access_code: !secret dsc_access_code
  
  # Enhanced debugging and monitoring
  debug: 1  # Enable debug output: 0=off, 1=status changes, 2=+05/27 packets, 3=all packets
  
  # Enhanced message processing for Classic panels
  enable_05_messages: true
  
  # Event handlers for system integration
  on_system_status_change:
    then:
      - text_sensor.template.publish:
          id: system_status
          state: !lambda 'return status;'
      - logger.log:
          format: "DSC System Status Changed: %s"
          args: ['status.c_str()']
          
  on_partition_status_change:
    then:
      - lambda: |-
          switch(partition) {
            case 1: id(p1).publish_state(status); break;
          }
      - logger.log:
          format: "DSC Partition %d Status Changed: %s"
          args: ['partition', 'status.c_str()']
          
  on_partition_msg_change:
    then:
      - lambda: |-
          switch(partition) {
            case 1: id(m1).publish_state(msg); break;
          }
          
  on_trouble_status_change:
    then:
      - binary_sensor.template.publish:
          id: trouble_status
          state: !lambda 'return trouble;'
          
  on_fire_status_change:
    then:
      - lambda: |-
          switch(partition) {
            case 1: id(fire_alarm_status).publish_state(fire); break;
          }
          
  on_zone_status_change:
    then:
      - lambda: |-
          switch(zone) {
            case 1: id(zone_1).publish_state(open); break;
            case 2: id(zone_2).publish_state(open); break;
            case 3: id(zone_3).publish_state(open); break;
            case 4: id(zone_4).publish_state(open); break;
            case 5: id(zone_5).publish_state(open); break;
            case 6: id(zone_6).publish_state(open); break;
            case 7: id(zone_7).publish_state(open); break;
            case 8: id(zone_8).publish_state(open); break;
          }
          
  on_zone_alarm_change:
    then:
      - lambda: |-
          switch(zone) {
            case 1: id(zone_1_alarm).publish_state(open); break;
            case 2: id(zone_2_alarm).publish_state(open); break;
            case 3: id(zone_3_alarm).publish_state(open); break;
            case 4: id(zone_4_alarm).publish_state(open); break;
            case 5: id(zone_5_alarm).publish_state(open); break;
            case 6: id(zone_6_alarm).publish_state(open); break;
            case 7: id(zone_7_alarm).publish_state(open); break;
            case 8: id(zone_8_alarm).publish_state(open); break;
          }

# Text sensors for DSC status
text_sensor:
  - platform: template
    id: system_status
    name: "DSC System Status"
    icon: "mdi:shield"
    
  - platform: template
    id: p1
    name: "DSC Partition 1 Status"  
    icon: "mdi:shield"
    
  - platform: template
    id: m1
    name: "DSC Partition 1 Message"
    icon: "mdi:alert-box"
    
  # System version and build info (MISSING from original config)
  - platform: version
    name: "DSC Alarm ESPHome Version"
    icon: "mdi:tag"
    
  # WiFi connection info (MISSING from original config)
  - platform: wifi_info
    ip_address:
      name: "DSC Alarm IP Address"
    ssid:
      name: "DSC Alarm WiFi SSID"
    mac_address:
      name: "DSC Alarm MAC Address"

# Binary sensors for DSC zones and partitions
binary_sensor:
  # Partition 1 sensors - using platform template for ESPHome compatibility
  - platform: template
    id: partition_1_ready
    name: "Partition 1 Ready"
    device_class: safety
      
  - platform: template
    id: partition_1_armed
    name: "Partition 1 Armed"
    device_class: safety
      
  - platform: template
    id: partition_1_armed_stay
    name: "Partition 1 Armed Stay"
    device_class: safety
      
  - platform: template
    id: partition_1_armed_away
    name: "Partition 1 Armed Away" 
    device_class: safety
      
  - platform: template
    id: partition_1_entry_delay
    name: "Partition 1 Entry Delay"
    device_class: safety
      
  - platform: template
    id: partition_1_exit_delay
    name: "Partition 1 Exit Delay"
    device_class: safety
      
  - platform: template
    id: partition_1_alarm
    name: "Partition 1 Alarm"
    device_class: safety

  # System status sensors
  - platform: template
    id: keybus_connected
    name: "DSC Keybus Connected"
    device_class: connectivity
      
  - platform: template
    id: trouble_status
    name: "System Trouble"
    device_class: problem
    
  - platform: template
    id: fire_alarm_status
    name: "Fire Alarm Status"
    device_class: safety

  # Zone sensors (8 zones for classic panels)
  - platform: template
    id: zone_1
    name: "Zone 1"
    device_class: door
      
  - platform: template
    id: zone_2
    name: "Zone 2"
    device_class: door
      
  - platform: template
    id: zone_3
    name: "Zone 3"
    device_class: window
      
  - platform: template
    id: zone_4
    name: "Zone 4"
    device_class: window
      
  - platform: template
    id: zone_5
    name: "Zone 5"
    device_class: motion
      
  - platform: template
    id: zone_6
    name: "Zone 6"
    device_class: motion
      
  - platform: template
    id: zone_7
    name: "Zone 7"
    device_class: motion
      
  - platform: template
    id: zone_8
    name: "Zone 8"
    device_class: motion
    
  # Zone alarm status sensors (MISSING from original config)
  - platform: template
    id: zone_1_alarm
    name: "Zone 1 Alarm"
    device_class: safety
    
  - platform: template
    id: zone_2_alarm
    name: "Zone 2 Alarm"
    device_class: safety
    
  - platform: template
    id: zone_3_alarm
    name: "Zone 3 Alarm"
    device_class: safety
    
  - platform: template
    id: zone_4_alarm
    name: "Zone 4 Alarm"
    device_class: safety
    
  - platform: template
    id: zone_5_alarm
    name: "Zone 5 Alarm"
    device_class: safety
    
  - platform: template
    id: zone_6_alarm
    name: "Zone 6 Alarm"
    device_class: safety
    
  - platform: template
    id: zone_7_alarm
    name: "Zone 7 Alarm"
    device_class: safety
    
  - platform: template
    id: zone_8_alarm
    name: "Zone 8 Alarm"
    device_class: safety

# Switches for DSC control
switch:
  - platform: template
    name: "Partition 1 Arm Stay"
    id: partition_1_arm_stay
    icon: "mdi:shield-home"
    turn_on_action:
      - lambda: |-
          id(dsc_interface).write("s");
      
  - platform: template
    name: "Partition 1 Arm Away"
    id: partition_1_arm_away
    icon: "mdi:shield-lock"
    turn_on_action:
      - lambda: |-
          id(dsc_interface).write("w");
      
  - platform: template
    name: "Partition 1 Disarm"
    id: partition_1_disarm
    icon: "mdi:shield-off"
    turn_on_action:
      - lambda: |-
          // Use access code for disarm - allows immediate disarm without waiting for flags
          std::string disarm_cmd = "${accessCode}";
          id(dsc_interface).write(disarm_cmd.c_str());

# Emergency alarm buttons (MISSING from original config - based on @taligentx interface)
button:
  - platform: template
    name: "Fire Alarm"
    id: fire_alarm_button
    icon: "mdi:fire"
    on_press:
      - lambda: |-
          id(dsc_interface).write("f");
          
  - platform: template  
    name: "Aux Alarm"
    id: aux_alarm_button
    icon: "mdi:hospital-box"
    on_press:
      - lambda: |-
          id(dsc_interface).write("a");
          
  - platform: template
    name: "Panic Alarm" 
    id: panic_alarm_button
    icon: "mdi:police-badge"
    on_press:
      - lambda: |-
          id(dsc_interface).write("p");

# System health monitoring sensors (MISSING from original config)
sensor:
  - platform: uptime
    name: "DSC Alarm Uptime"
    id: uptime_seconds
    update_interval: 60s
    icon: "mdi:timer-outline"
    unit_of_measurement: s
    device_class: duration
    state_class: total_increasing
  
  - platform: wifi_signal
    name: "DSC Alarm WiFi Signal"
    id: wifi_signal_db
    update_interval: 60s
    unit_of_measurement: dBm
    device_class: signal_strength
    state_class: measurement
    icon: "mdi:wifi"

# Advanced services for Home Assistant integration
api:
  services:
    - service: send_keypad_command
      variables:
        command: string
      then:
        - lambda: |-
            id(dsc_interface).write(command.c_str());
            
    - service: arm_stay_partition_1
      then:
        - lambda: |-
            id(dsc_interface).write("s");
            
    - service: arm_away_partition_1  
      then:
        - lambda: |-
            id(dsc_interface).write("w");
            
    - service: disarm_partition_1
      then:
        - lambda: |-
            // CRITICAL FIX: Immediate disarm using access code without waiting for flags
            std::string disarm_cmd = "${accessCode}";
            id(dsc_interface).write(disarm_cmd.c_str());
            
    - service: panic_alarm
      then:
        - lambda: |-
            id(dsc_interface).write("p");
            
    - service: fire_alarm
      then:
        - lambda: |-
            id(dsc_interface).write("f");
            
    - service: aux_alarm
      then:
        - lambda: |-
            id(dsc_interface).write("a");

# Time component for DSC timing functions
time:
  - platform: sntp
    id: sntp_time
    servers:
      - pool.ntp.org
    on_time_sync:
      then:
        - logger.log: "Time synchronized for DSC operations"

# Status LED to indicate DSC connection status  
status_led:
  pin: GPIO2

# Optional: Deep sleep prevention during active monitoring
deep_sleep:
  prevent_deep_sleep: true