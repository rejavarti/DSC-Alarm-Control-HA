# DSC Keybus Interface for ESPHome (ESP32)
# Supports both DSC PowerSeries AND Classic series panels
# Uses local dscKeybusInterface implementation (NOT the external Dilbert66/esphome-dsckeybus)
# 
# Classic Series Support: PC1500, PC1550, PC1832, PC1864, PC1616, etc.
# PowerSeries Support: PC1555MX, PC5015, PC1616, PC1832, PC1864, etc.
#
# ===== IMPORTANT FOR DSC CLASSIC SERIES =====
# If you have a DSC Classic series panel, you MUST:
# 1. Uncomment the build_flags section below
# 2. Ensure PC-16 wiring (additional 1kÎ© resistor to GPIO 17)
# 3. Configure PGM output in your DSC panel for PC-16
#
# ESP32 Pin Assignments:
# - Clock: GPIO 18
# - Data (Read): GPIO 19
# - Data (Write): GPIO 21  
# - PC-16 (Classic only): GPIO 17

substitutions:
  accessCode: !secret access_code #Only comes into effect if a password prompt occurs when arming eg. night mode

esphome:
  name: dscalarm
  # ===== DSC CLASSIC SERIES ONLY =====
  # Uncomment these 2 lines ONLY if you have a DSC Classic series panel:
  # NOTE: build_flags must be under esp32: section, NOT under esphome: section
  # build_flags:
  #   - -DdscClassicSeries

external_components:
  - source:
      type: local
      path: components
    components: [dsc_keybus]
  #   - -DdscClassicSeries

esp32:
  board: esp32dev
  framework:
    type: esp-idf
    # Use ESPHome default versions for maximum compatibility
    
    # ESP-IDF specific configurations to prevent boot hanging
    sdkconfig_options:
      # Main task stack size - increase to prevent stack overflow during init
      CONFIG_ESP_MAIN_TASK_STACK_SIZE: "16384"  # Default is 3584, increase to 16KB
      
      # System event task stack size
      CONFIG_ESP_SYSTEM_EVENT_TASK_STACK_SIZE: "4096"  # Increase to 4KB
      
      # Timer task stack size  
      CONFIG_FREERTOS_TIMER_TASK_STACK_DEPTH: "4096"  # Increase to 4KB
      
      # WiFi task stack sizes for stability
      CONFIG_ESP32_WIFI_TASK_STACK_SIZE: "6144"  # Increase to 6KB
      CONFIG_ESP32_WIFI_RX_BUFFER_NUM: "16"     # Increase WiFi buffers
      CONFIG_ESP32_WIFI_TX_BUFFER_NUM: "16"
      
      # Memory management optimizations
      CONFIG_ESP_SYSTEM_EVENT_QUEUE_SIZE: "64"  # Increase event queue
      CONFIG_FREERTOS_HZ: "1000"                # 1ms tick for responsive DSC processing
      
      # Watchdog timer configurations
      CONFIG_ESP_TASK_WDT_TIMEOUT_S: "30"       # 30 second timeout
      CONFIG_ESP_TASK_WDT_EN: y                 # Enable watchdog
      CONFIG_ESP_TASK_WDT_INIT: y               # Initialize early
      
      # Interrupt timing for DSC Keybus
      CONFIG_ESP_INT_WDT_TIMEOUT_MS: "2000"    # 2 second interrupt watchdog
      
      # Disable power management for consistent DSC timing
      CONFIG_PM_ENABLE: n
      
  # ===== DSC CLASSIC SERIES ONLY =====
  # Uncomment these lines ONLY if you have a DSC Classic series panel:
  # (Note: you should use DscAlarm_Classic_ESP32.yaml instead for pre-configured setup)
  #
  # esphome:
  #   platformio_options:
  #     build_flags:
  #       - -DdscClassicSeries

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "DSCalarm"
    password: !secret wifi_password

logger:
  baud_rate: 0
  level: verbose

api:
  password: !secret api_password  

mqtt:
  broker: !secret mqtt_broker
  username: !secret mqtt_username  
  password: !secret mqtt_password
  discovery: true
  discovery_prefix: homeassistant
  topic_prefix: esphome/dscalarm
   
ota:
  - platform: esphome
    password: !secret ota_password

safe_mode:
  disabled: false
   
status_led:
  pin:
    number: GPIO2
    inverted: yes

dsc_keybus:
  id: dsc_interface
  access_code: "$accessCode"
  debug: 0  # 0 = off, 1 = status change data, 2 = + 05/27 packets, 3 = + all packets received
  on_system_status_change:
    then:
      - text_sensor.template.publish:
          id: system_status
          state: !lambda 'return status;'
  on_partition_status_change:
    then:
      - lambda: |-
          switch(partition) {
            case 1: id(p1).publish_state(status); break;
            case 2: id(p2).publish_state(status); break;
          }
  on_partition_msg_change:
    then:
      - lambda: |-
          switch(partition) {
            case 1: id(m1).publish_state(msg); break;
            case 2: id(m2).publish_state(msg); break;
          }
  on_trouble_status_change:
    then:
      - binary_sensor.template.publish:
          id: t1
          state: !lambda 'return trouble;'
  on_fire_status_change:
    then:
      - lambda: |-
          switch(partition) {
            case 1: id(f1).publish_state(fire); break;
          }
  on_zone_status_change:
    then:
      - lambda: |-
          switch(zone) {
            case 1: id(z1).publish_state(open); break;
            case 2: id(z2).publish_state(open); break;
            case 3: id(z3).publish_state(open); break;
            case 4: id(z4).publish_state(open); break;
            case 5: id(z5).publish_state(open); break;
            case 6: id(z6).publish_state(open); break;
            case 7: id(z7).publish_state(open); break;
            case 8: id(z8).publish_state(open); break;
            case 9: id(z9).publish_state(open); break;
            case 10: id(z10).publish_state(open); break;
            case 11: id(z11).publish_state(open); break;
          }
  on_zone_alarm_change:
    then:
      - lambda: |-
          switch(zone) {
            case 1: id(za1).publish_state(open); break;
            case 2: id(za2).publish_state(open); break;
            case 3: id(za3).publish_state(open); break;
            case 4: id(za4).publish_state(open); break;
            case 5: id(za5).publish_state(open); break;
            case 6: id(za6).publish_state(open); break;
            case 7: id(za7).publish_state(open); break;
            case 8: id(za8).publish_state(open); break;
            case 9: id(za9).publish_state(open); break;
            case 10: id(za10).publish_state(open); break;
            case 11: id(za11).publish_state(open); break;
          }

binary_sensor:
  # Zone status sensors
  - platform: template
    id: z1
    name: "Zone Front door"
    device_class: door
  - platform: template
    id: z2
    name: "Zone Garage door"
    device_class: door
  - platform: template
    id: z3
    name: "Zone Back door"
    device_class: door
  - platform: template
    id: z4
    name: "Zone Living room window"
    device_class: window
  - platform: template
    id: z5
    name: "Zone Dining room window"
    device_class: window
  - platform: template
    id: z6
    name: "Zone Family room window LF"
    device_class: window
  - platform: template
    id: z7
    name: "Zone Family room window RF"
    device_class: window
  - platform: template
    id: z8
    name: "Zone Basement windows"
    device_class: window
  - platform: template
    id: z9
    name: "Zone Upstairs motion"
    device_class: motion
  - platform: template
    id: z10
    name: "Zone Basement motion"
    device_class: motion
  - platform: template
    id: z11
    name: "Zone Main floor motion"
    device_class: motion
    
  # Zone alarm status sensors
  - platform: template
    id: za1
    name: "Zone Front door alarm"
    device_class: safety
  - platform: template
    id: za2
    name: "Zone Garage door alarm"
    device_class: safety
  - platform: template
    id: za3
    name: "Zone Back door alarm"
    device_class: safety
  - platform: template
    id: za4
    name: "Zone Living room window alarm"
    device_class: safety
  - platform: template
    id: za5
    name: "Zone Dining room window alarm"
    device_class: safety
  - platform: template
    id: za6
    name: "Zone Family room window LF alarm"
    device_class: safety
  - platform: template
    id: za7
    name: "Zone Family room window RF alarm"
    device_class: safety
  - platform: template
    id: za8
    name: "Zone Basement windows alarm"
    device_class: safety
  - platform: template
    id: za9
    name: "Zone Upstairs motion alarm"
    device_class: safety
  - platform: template
    id: za10
    name: "Zone Basement motion alarm"
    device_class: safety
  - platform: template
    id: za11
    name: "Zone Main floor motion alarm"
    device_class: safety
    
  # System status sensors
  - platform: template
    id: t1
    name: "DSCAlarm Trouble Status"
    device_class: problem
    
  - platform: template
    id: f1
    device_class: safety
    name: "DSCAlarm Partition1 Fire Status"
    
  # System connectivity and health sensors
  - platform: status
    name: "DSCAlarm System Status"
    id: system_status_sensor
    device_class: connectivity
    
  # System health monitoring
  - platform: template
    name: "DSCAlarm System Healthy"
    id: system_healthy_sensor
    device_class: problem
    lambda: |-
      // System is healthy if WiFi connected, API connected, and no buffer overflow
      bool wifi_ok = wifi::global_wifi_component->is_connected();
      bool api_ok = api::global_api_server->is_connected();
      bool heap_ok = esp_get_free_heap_size() > 10000; // At least 10KB free
      return wifi_ok && api_ok && heap_ok;
    
  # DSC Keybus connection status  
  - platform: template
    name: "DSCAlarm Keybus Connected"
    id: keybus_connected_sensor
    device_class: connectivity
    lambda: |-
      return id(dsc_interface).getKeybusConnected();
      
  # DSC Buffer overflow detection
  - platform: template
    name: "DSCAlarm Buffer Overflow"
    id: buffer_overflow_sensor  
    device_class: problem
    lambda: |-
      return id(dsc_interface).getBufferOverflow();

text_sensor:
  - platform: template
    id: system_status
    name: "DSCAlarm System Status"
    icon: "mdi:shield"
  - platform: template
    id: p1
    name: "DSCAlarm Partition 1 Status"
    icon: "mdi:shield"
  - platform: template
    id: p2
    name: "DSCAlarm Partition 2 Status"
    icon: "mdi:shield"  
  - platform: template
    id: m1
    name: "DSCAlarm Partition 1 Msg"
    icon: "mdi:alert-box"
  - platform: template
    id: m2
    name: "DSCAlarm Partition 2 Msg"
    icon: "mdi:alert-box"
  # System version and build info
  - platform: version
    name: "DSCAlarm ESPHome Version"
    icon: "mdi:tag"
  # WiFi connection info  
  - platform: wifi_info
    ip_address:
      name: "DSCAlarm IP Address"
    ssid:
      name: "DSCAlarm WiFi SSID"
    mac_address:
      name: "DSCAlarm MAC Address"
      
  # System error tracking
  - platform: template
    name: "DSCAlarm Last Error"
    id: last_error_sensor
    icon: "mdi:alert-circle"
    lambda: |-
      static std::string last_error = "None";
      return last_error;

sensor:
  # System uptime
  - platform: uptime
    name: "DSCAlarm Uptime"
    id: uptime_seconds
    update_interval: 60s
    icon: "mdi:timer-outline"
    unit_of_measurement: s
    device_class: duration
    state_class: total_increasing
  
  # WiFi signal strength  
  - platform: wifi_signal
    name: "DSCAlarm WiFi Signal"
    id: wifi_signal_db
    update_interval: 60s
    unit_of_measurement: dBm
    device_class: signal_strength
    state_class: measurement
    icon: "mdi:wifi-strength-2"
    
  # System diagnostics - Free heap memory
  - platform: template
    name: "DSCAlarm Free Heap"
    id: free_heap_sensor
    update_interval: 60s
    unit_of_measurement: "bytes"
    state_class: measurement
    icon: "mdi:memory"
    lambda: |-
      return esp_get_free_heap_size();
      
  # WiFi reconnection counter
  - platform: template
    name: "DSCAlarm WiFi Reconnects"
    id: wifi_reconnects_sensor
    update_interval: 60s
    state_class: total_increasing
    icon: "mdi:wifi-sync"
    lambda: |-
      static uint32_t reconnect_count = 0;
      if (!wifi::global_wifi_component->is_connected()) {
        reconnect_count++;
      }
      return reconnect_count;

# Periodic system health monitoring
interval:
  - interval: 60s
    then:
      - lambda: |-
          // Update system health status
          bool wifi_ok = wifi::global_wifi_component->is_connected();
          bool api_ok = api::global_api_server->is_connected(); 
          bool heap_ok = esp_get_free_heap_size() > 10000;
          bool system_ok = wifi_ok && api_ok && heap_ok;
          
          id(system_healthy_sensor).publish_state(system_ok);
          
          // Log system health if issues detected
          if (!system_ok) {
            ESP_LOGW("system_health", "System health issue detected - WiFi: %s, API: %s, Heap: %s", 
              wifi_ok ? "OK" : "FAIL", 
              api_ok ? "OK" : "FAIL",
              heap_ok ? "OK" : "FAIL");
          }

button:
  # Emergency buttons
  - platform: template
    name: "Fire Alarm"
    id: fire_alarm_button
    icon: "mdi:fire"
    on_press:
      - lambda: |-
          id(dsc_interface).alarm_keypress("f");
          
  - platform: template  
    name: "Aux Alarm"
    id: aux_alarm_button
    icon: "mdi:hospital-box"
    on_press:
      - lambda: |-
          id(dsc_interface).alarm_keypress("a");
          
  - platform: template
    name: "Panic Alarm" 
    id: panic_alarm_button
    icon: "mdi:police-badge"
    on_press:
      - lambda: |-
          id(dsc_interface).alarm_keypress("p");

switch:
  - platform: template
    name: "DSCAlarm Connection"
    id: connection_status_switch
    lambda: |-
      return esphome::dsc_keybus::getDSC().getKeybusConnected();
    icon: "mdi:shield-link-variant"
    turn_on_action:
      - switch.toggle: restart_switch
    turn_off_action:
      - lambda: |-
          esphome::dsc_keybus::getDSC().stop();
  - platform: restart
    id: restart_switch