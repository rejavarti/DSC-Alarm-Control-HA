# Simple ESPHome test configuration to validate "Returned from app_main()" hang fix
# This configuration tests the core ESP-IDF settings without complex components

substitutions:
  device_name: "esphome-startup-test"

esphome:
  name: ${device_name}
  # Enhanced project configuration for ESPHome startup after app_main()
  platformio_options:
    build_flags:
      - -DESPHOME_STARTUP_TEST              # Enable test mode

esp32:
  board: esp32dev
  framework:
    type: esp-idf
    
    # CRITICAL: Enhanced ESP-IDF configuration to prevent ESPHome startup hang after app_main()
    # These settings ensure ESPHome properly takes control after "Returned from app_main()"
    sdkconfig_options:
      # CRITICAL: Main task configuration for ESPHome initialization
      CONFIG_ESP_MAIN_TASK_STACK_SIZE: "32768"        # 32KB for ESPHome startup (vs 3.5KB default)
      CONFIG_ESP_MAIN_TASK_AFFINITY_CPU0: y           # Pin to CPU0 for consistent scheduling
      CONFIG_ESP_MAIN_TASK_PRIORITY: "1"              # High priority for ESPHome startup
      
      # Enhanced system event task for ESPHome component initialization  
      CONFIG_ESP_SYSTEM_EVENT_TASK_STACK_SIZE: "8192"  # 8KB for component events
      CONFIG_ESP_SYSTEM_EVENT_TASK_PRIORITY: "20"      # Appropriate priority for system events
      
      # FreeRTOS scheduler optimizations for ESPHome main loop
      CONFIG_FREERTOS_TIMER_TASK_STACK_DEPTH: "8192"   # 8KB timer task for ESPHome
      CONFIG_FREERTOS_TIMER_TASK_PRIORITY: "22"        # High priority for ESPHome timers
      CONFIG_FREERTOS_IDLE_TASK_STACKSIZE: "4096"      # 4KB idle task (vs 1.5KB default)
      CONFIG_FREERTOS_HZ: "1000"                       # 1ms tick for responsive ESPHome operation
      
      # CRITICAL: Enhanced task watchdog for ESPHome component initialization
      # Prevents system hang during component setup after app_main() returns
      CONFIG_ESP_TASK_WDT_TIMEOUT_S: "300"             # 5 minutes timeout for full initialization
      CONFIG_ESP_TASK_WDT_EN: y                        # Enable task watchdog
      CONFIG_ESP_TASK_WDT_INIT: y                      # Initialize watchdog early
      CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_CPU0: y      # Monitor idle task on CPU0
      CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_CPU1: y      # Monitor idle task on CPU1
      CONFIG_ESP_TASK_WDT_PANIC: n                     # Reset instead of panic on timeout
      CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_ALL_CORES: y # Monitor all cores
      
      # Interrupt watchdog for system stability
      CONFIG_ESP_INT_WDT_EN: y                         # Enable interrupt watchdog
      CONFIG_ESP_INT_WDT_TIMEOUT_MS: "10000"           # 10 second timeout
      CONFIG_ESP_INT_WDT_CHECK_CPU1: y                 # Monitor both CPUs
      
      # CPU and clock configuration for optimal ESPHome performance
      CONFIG_ESP32_DEFAULT_CPU_FREQ_240: y             # Maximum CPU frequency
      CONFIG_ESP32_DEFAULT_CPU_FREQ_MHZ: "240"         # 240MHz for fast initialization
      CONFIG_ESP32_DEFAULT_CPU_FREQ_80: n              # Disable lower frequencies
      CONFIG_ESP32_DEFAULT_CPU_FREQ_160: n
      CONFIG_ESP32_XTAL_FREQ_40: y                     # 40MHz crystal for stable 240MHz
      CONFIG_ESP32_XTAL_FREQ_26: n
      
      # CRITICAL: Disable power management for consistent ESPHome operation
      CONFIG_PM_ENABLE: n                              # No power management interference
      
      # Memory management optimizations for ESPHome startup
      CONFIG_ESP_SYSTEM_EVENT_QUEUE_SIZE: "128"        # Large event queue for components
      CONFIG_HEAP_POISONING_LIGHT: y                   # Light heap debugging (low overhead)
      CONFIG_HEAP_POISONING_COMPREHENSIVE: n           # Avoid heavy memory overhead
      CONFIG_HEAP_TRACING_STANDALONE: n                # Disable to save memory during startup
      CONFIG_HEAP_ABORT_WHEN_ALLOCATION_FAILS: n       # Allow graceful handling of allocation failures

# WiFi configuration - Use AP mode to avoid connection delays during testing
wifi:
  ap:
    ssid: "ESPHome-Startup-Test"
    password: "test123456"

# Enhanced logging to monitor ESPHome startup progress
logger:
  level: DEBUG
  baud_rate: 115200
  hardware_uart: UART0

# Basic API without encryption for initial testing
api:

# Basic OTA for testing
ota:
  - platform: esphome

# System health monitoring to confirm ESPHome main loop is running
binary_sensor:
  - platform: template
    name: "ESPHome Started Successfully"
    id: esphome_started
    lambda: |-
      // This lambda will only execute if ESPHome main loop is running
      // If this sensor shows 'true', the startup hang is fixed
      return true;
    
  - platform: template
    name: "System Healthy"
    id: system_healthy
    lambda: |-
      // Monitor system health indicators
      size_t free_heap = esp_get_free_heap_size();
      bool heap_ok = free_heap > 50000;  // At least 50KB free
      return heap_ok;

# System monitoring sensors
sensor:
  - platform: uptime
    name: "System Uptime"
    id: system_uptime
    update_interval: 60s
    
  - platform: template
    name: "Free Heap Memory"
    id: free_heap_sensor
    unit_of_measurement: "bytes"
    accuracy_decimals: 0
    update_interval: 30s
    lambda: |-
      size_t free_heap = esp_get_free_heap_size();
      return free_heap;

# Text sensors for system information
text_sensor:
  - platform: template
    name: "ESP-IDF Version"
    id: esp_idf_version
    update_interval: never
    lambda: |-
      return {"ESP-IDF " + to_string(ESP_IDF_VERSION_MAJOR) + "." + 
              to_string(ESP_IDF_VERSION_MINOR) + "." + 
              to_string(ESP_IDF_VERSION_PATCH)};
              
  - platform: template
    name: "Startup Status"
    id: startup_status
    update_interval: never
    lambda: |-
      return {"ESPHome startup after app_main() - SUCCESS"};

# Startup monitoring interval to confirm main loop operation
interval:
  - interval: 5s
    then:
      - lambda: |-
          static bool startup_logged = false;
          static uint32_t loop_counter = 0;
          
          loop_counter++;
          
          if (!startup_logged) {
            ESP_LOGI("startup_fix", "SUCCESS: ESPHome main loop started after app_main() returned!");
            ESP_LOGI("startup_fix", "System uptime: %.1f seconds", id(system_uptime).state);
            ESP_LOGI("startup_fix", "Free heap: %zu bytes", esp_get_free_heap_size());
            ESP_LOGI("startup_fix", "Stack high water mark: %zu bytes", uxTaskGetStackHighWaterMark(nullptr));
            startup_logged = true;
          }
          
          // Periodic health check
          if (loop_counter % 12 == 0) {  // Every 60 seconds
            size_t free_heap = esp_get_free_heap_size();
            size_t stack_hwm = uxTaskGetStackHighWaterMark(nullptr);
            ESP_LOGD("health", "System health - uptime: %.1f, heap: %zu, stack: %zu", 
                     id(system_uptime).state, free_heap, stack_hwm);
          }

# Status LED to provide visual confirmation of successful startup
status_led:
  pin:
    number: GPIO2
    inverted: yes

# Button to test system responsiveness
button:
  - platform: template
    name: "Test System Response"
    id: test_response_button
    on_press:
      - lambda: |-
          ESP_LOGI("test", "System responsive! Uptime: %.1f seconds", id(system_uptime).state);
          ESP_LOGI("test", "Free heap: %zu bytes", esp_get_free_heap_size());