substitutions:
  accessCode: "1234" # Test access code for standalone mode

esphome:
  name: dscalarm-standalone-test
  # DSC Classic series build flag - REQUIRED for Classic panels
  # NOTE: build_flags must be under esphome: section using platformio_options
  platformio_options:
    build_flags:
      - -DdscClassicSeries

external_components:
  - source:
      type: local
      path: components
    components: [dsc_keybus]

esp32:
  board: esp32dev
  framework:
    type: esp-idf

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "DSCalarm-Standalone"
    password: !secret wifi_password

logger:
  baud_rate: 0
  level: verbose

api:
  encryption:
    key: !secret encryption_key

ota:
  - platform: esphome
    password: !secret ota_password

safe_mode:
  disabled: false
   
status_led:
  pin:
    number: GPIO2
    inverted: yes

# DSC Keybus configuration with standalone mode enabled
dsc_keybus:
  id: dsc_interface
  access_code: "$accessCode"
  series_type: "Classic"  # Explicitly set for DSC Classic series panels
  standalone_mode: true   # ENABLE STANDALONE MODE - No physical panel connection required
  debug: 1  # Enable debug logging to see standalone mode messages
  on_system_status_change:
    then:
      - text_sensor.template.publish:
          id: system_status
          state: !lambda 'return status;'
  on_partition_status_change:
    then:
      - lambda: |-
          switch(partition) {
            case 1: id(p1).publish_state(status); break;
            case 2: id(p2).publish_state(status); break;
          }
  on_partition_msg_change:
    then:
      - lambda: |-
          switch(partition) {
            case 1: id(m1).publish_state(msg); break;
            case 2: id(m2).publish_state(msg); break;
          }
  on_trouble_status_change:
    then:
      - binary_sensor.template.publish:
          id: t1
          state: !lambda 'return trouble;'
  on_fire_status_change:
    then:
      - lambda: |-
          switch(partition) {
            case 1: id(f1).publish_state(fire); break;
          }
  on_zone_status_change:
    then:
      - lambda: |-
          switch(zone) {
            case 1: id(z1).publish_state(open); break;
            case 2: id(z2).publish_state(open); break;
            case 3: id(z3).publish_state(open); break;
            case 4: id(z4).publish_state(open); break;
          }
  on_zone_alarm_change:
    then:
      - lambda: |-
          switch(zone) {
            case 1: id(za1).publish_state(open); break;
            case 2: id(za2).publish_state(open); break;
            case 3: id(za3).publish_state(open); break;
            case 4: id(za4).publish_state(open); break;
          }

binary_sensor:
  # Zone status sensors (reduced for standalone testing)
  - platform: template
    id: z1
    name: "Zone Front door (Test)"
    device_class: door
  - platform: template
    id: z2
    name: "Zone Back door (Test)"
    device_class: door
  - platform: template
    id: z3
    name: "Zone Window (Test)"
    device_class: window
  - platform: template
    id: z4
    name: "Zone Motion (Test)"
    device_class: motion
    
  # Zone alarm status sensors
  - platform: template
    id: za1
    name: "Zone Front door alarm (Test)"
    device_class: safety
  - platform: template
    id: za2
    name: "Zone Back door alarm (Test)"
    device_class: safety
  - platform: template
    id: za3
    name: "Zone Window alarm (Test)"
    device_class: safety
  - platform: template
    id: za4
    name: "Zone Motion alarm (Test)"
    device_class: safety
    
  # System status sensors
  - platform: template
    id: t1
    name: "DSCAlarm Trouble Status (Test)"
    device_class: problem
    
  - platform: template
    id: f1
    device_class: safety
    name: "DSCAlarm Partition1 Fire Status (Test)"
    
  # System connectivity and health sensors
  - platform: status
    name: "DSCAlarm System Status (Test)"
    id: system_status_sensor
    device_class: connectivity
    
  # System health monitoring
  - platform: template
    name: "DSCAlarm System Healthy (Test)"
    id: system_healthy_sensor
    device_class: problem
    lambda: |-
      // System is healthy if WiFi connected, API connected, and no buffer overflow
      bool wifi_ok = wifi::global_wifi_component->is_connected();
      bool api_ok = api::global_api_server->is_connected();
      bool heap_ok = esp_get_free_heap_size() > 10000; // At least 10KB free
      return wifi_ok && api_ok && heap_ok;

text_sensor:
  - platform: template
    id: system_status
    name: "DSCAlarm System Status (Test)"
    icon: "mdi:shield"
  - platform: template
    id: p1
    name: "DSCAlarm Partition 1 Status (Test)"
    icon: "mdi:shield"
  - platform: template
    id: p2
    name: "DSCAlarm Partition 2 Status (Test)"
    icon: "mdi:shield"  
  - platform: template
    id: m1
    name: "DSCAlarm Partition 1 Msg (Test)"
    icon: "mdi:alert-box"
  - platform: template
    id: m2
    name: "DSCAlarm Partition 2 Msg (Test)"
    icon: "mdi:alert-box"
  # System version and build info
  - platform: version
    name: "DSCAlarm ESPHome Version (Test)"
    icon: "mdi:tag"
  # WiFi connection info  
  - platform: wifi_info
    ip_address:
      name: "DSCAlarm IP Address (Test)"
    ssid:
      name: "DSCAlarm WiFi SSID (Test)"
    mac_address:
      name: "DSCAlarm MAC Address (Test)"
      
  # Standalone mode indicator
  - platform: template
    name: "DSCAlarm Mode"
    id: mode_indicator
    icon: "mdi:test-tube"
    lambda: |-
      return {"Standalone Test Mode - No Panel Required"};

sensor:
  # System uptime
  - platform: uptime
    name: "DSCAlarm Uptime (Test)"
    id: uptime_seconds
    update_interval: 60s
    icon: "mdi:timer-outline"
    unit_of_measurement: s
    device_class: duration
    state_class: total_increasing
  
  # WiFi signal strength  
  - platform: wifi_signal
    name: "DSCAlarm WiFi Signal (Test)"
    id: wifi_signal_db
    update_interval: 60s
    unit_of_measurement: dBm
    device_class: signal_strength
    state_class: measurement
    icon: "mdi:wifi-strength-2"
    
  # System diagnostics - Free heap memory
  - platform: template
    name: "DSCAlarm Free Heap (Test)"
    id: free_heap_sensor
    update_interval: 30s
    unit_of_measurement: "bytes"
    state_class: measurement
    icon: "mdi:memory"
    lambda: |-
      return esp_get_free_heap_size();
      
  # Largest free block (for testing memory allocation)
  - platform: template
    name: "DSCAlarm Largest Free Block (Test)"
    id: largest_free_block_sensor
    update_interval: 30s
    unit_of_measurement: "bytes"
    state_class: measurement
    icon: "mdi:memory"
    lambda: |-
      return heap_caps_get_largest_free_block(MALLOC_CAP_8BIT);
      
  # Stack high water mark
  - platform: template
    name: "DSCAlarm Stack High Water Mark (Test)"
    id: stack_high_water_mark_sensor
    update_interval: 60s
    unit_of_measurement: "bytes"
    state_class: measurement
    icon: "mdi:memory"
    lambda: |-
      return uxTaskGetStackHighWaterMark(NULL);

# Periodic system health monitoring
interval:
  - interval: 60s
    then:
      - lambda: |-
          // Update system health status
          bool wifi_ok = wifi::global_wifi_component->is_connected();
          bool api_ok = api::global_api_server->is_connected(); 
          bool heap_ok = esp_get_free_heap_size() > 10000;
          bool system_ok = wifi_ok && api_ok && heap_ok;
          
          id(system_healthy_sensor).publish_state(system_ok);
          
          // Log system health if issues detected
          if (!system_ok) {
            ESP_LOGW("system_health", "System health issue detected - WiFi: %s, API: %s, Heap: %s", 
              wifi_ok ? "OK" : "FAIL", 
              api_ok ? "OK" : "FAIL",
              heap_ok ? "OK" : "FAIL");
          } else {
            ESP_LOGI("system_health", "System healthy in standalone mode - WiFi connected, API available, heap sufficient");
          }

switch:
  # System restart
  - platform: restart
    id: restart_switch
    name: "DSCAlarm Restart (Test)"
    icon: "mdi:restart"