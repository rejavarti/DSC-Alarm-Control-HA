# DSC ESP32 Boot Diagnostic Configuration - Testing ESP32 Task Watchdog Fix
# This configuration is specifically designed to test and diagnose the ESP32 task watchdog timeout issue

substitutions:
  accessCode: !secret access_code

esphome:
  name: dscalarm-boot-diagnostic

external_components:
  - source:
      type: local
      path: components
    components: [dsc_keybus]

esp32:
  board: esp32dev
  framework:
    type: esp-idf
    # Enhanced ESP-IDF configuration to prevent task watchdog timeout
    sdkconfig_options:
      CONFIG_ESP_MAIN_TASK_STACK_SIZE: "32768"
      CONFIG_ESP_MAIN_TASK_AFFINITY_CPU0: y
      CONFIG_ESP_MAIN_TASK_PRIORITY: "1"
      CONFIG_ESP_SYSTEM_EVENT_TASK_STACK_SIZE: "8192"
      CONFIG_ESP_SYSTEM_EVENT_TASK_PRIORITY: "20"
      CONFIG_FREERTOS_TIMER_TASK_STACK_DEPTH: "8192"
      CONFIG_FREERTOS_TIMER_TASK_PRIORITY: "22"
      CONFIG_FREERTOS_IDLE_TASK_STACKSIZE: "4096"
      CONFIG_FREERTOS_HZ: "1000"
      CONFIG_ESP_TASK_WDT_TIMEOUT_S: "300"             # 5 minutes timeout
      CONFIG_ESP_TASK_WDT_EN: y
      CONFIG_ESP_TASK_WDT_INIT: y
      CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_CPU0: y
      CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_CPU1: y
      CONFIG_ESP_TASK_WDT_PANIC: n                     # Reset instead of panic
      CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_ALL_CORES: y
      CONFIG_ESP_INT_WDT_EN: y
      CONFIG_ESP_INT_WDT_TIMEOUT_MS: "10000"
      CONFIG_ESP_INT_WDT_CHECK_CPU1: y
      CONFIG_ESP32_DEFAULT_CPU_FREQ_240: y
      CONFIG_ESP32_DEFAULT_CPU_FREQ_MHZ: "240"
      CONFIG_ESP32_DEFAULT_CPU_FREQ_80: n
      CONFIG_ESP32_DEFAULT_CPU_FREQ_160: n
      CONFIG_ESP32_XTAL_FREQ_40: y
      CONFIG_ESP32_XTAL_FREQ_26: n
      CONFIG_PM_ENABLE: n
      CONFIG_ESP32_ENABLE_RTC_CLK_XTAL_32K: n
      CONFIG_ESP_SYSTEM_EVENT_QUEUE_SIZE: "128"
      CONFIG_HEAP_POISONING_LIGHT: y
      CONFIG_HEAP_POISONING_COMPREHENSIVE: n
      CONFIG_HEAP_TRACING_STANDALONE: n
      CONFIG_HEAP_ABORT_WHEN_ALLOCATION_FAILS: n

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "DSCalarm-Boot-Diagnostic"
    password: !secret wifi_password

logger:
  baud_rate: 0
  level: VERBOSE

api:
  encryption:
    key: !secret encryption_key

ota:
  - platform: esphome
    password: !secret ota_password

safe_mode:
  disabled: false

# DSC KEYBUS CONFIGURATION
dsc_keybus:
  id: dsc_interface
  access_code: "$accessCode"
  series_type: "Classic"  # Change to "PowerSeries" if using PowerSeries panels
  standalone_mode: false  # FALSE for physical panel connection diagnosis
  debug: 3  # MAXIMUM DEBUG - Shows all packets for troubleshooting
  clock_pin: 18    # DSC Yellow wire → ESP32 GPIO 18 (via 33kΩ resistor)
  read_pin: 19     # DSC Green wire → ESP32 GPIO 19 (via 33kΩ resistor)  
  write_pin: 21    # DSC Green wire write (shared with read_pin, via 33kΩ resistor)
  pc16_pin: 17     # DSC Brown wire → ESP32 GPIO 17 (DSC Classic only, via 1kΩ resistor)

# BASIC DIAGNOSTIC SENSORS
sensor:
  # System diagnostics
  - platform: uptime
    name: "DSC Uptime"
    id: uptime_seconds
    update_interval: 60s
    icon: "mdi:timer-outline"
    unit_of_measurement: s
    device_class: duration
    state_class: total_increasing
    
  - platform: template
    name: "DSC Free Heap"
    id: free_heap_sensor
    update_interval: 60s
    unit_of_measurement: "bytes"
    state_class: measurement
    icon: "mdi:memory"
    lambda: |-
      return esp_get_free_heap_size();

# ESP32 BOOT SUCCESS MONITORING  
interval:
  # ESPHome startup success monitoring (validates the app_main() hang fix)
  - interval: 30s
    then:
      - lambda: |-
          static bool startup_success_logged = false;
          
          if (!startup_success_logged) {
            ESP_LOGI("startup_fix", "✅ SUCCESS: ESPHome startup hang fix working!");
            ESP_LOGI("startup_fix", "ESP32 successfully transitioned from app_main() to ESPHome main loop");
            ESP_LOGI("startup_fix", "System uptime: %.1f seconds", id(uptime_seconds).state);
            ESP_LOGI("startup_fix", "Free heap: %zu bytes", esp_get_free_heap_size());
            ESP_LOGI("startup_fix", "Enhanced ESP-IDF configuration prevented task watchdog timeout");
            ESP_LOGI("startup_fix", "Testing ESP-IDF 5.3.2 task watchdog timeout fix");
            startup_success_logged = true;
          }

  # DSC Connection diagnostic every 30 seconds
  - interval: 30s
    then:
      - lambda: |-
          bool connected = id(dsc_interface).getKeybusConnected();
          
          ESP_LOGI("dsc_diagnostic", "=== DSC CONNECTION DIAGNOSTIC ===");
          ESP_LOGI("dsc_diagnostic", "Keybus Connected: %s", connected ? "YES" : "NO");
          ESP_LOGI("dsc_diagnostic", "Free Heap: %zu bytes", esp_get_free_heap_size());
          
          if (!connected) {
            ESP_LOGW("dsc_diagnostic", "DSC panel not responding - check:");
            ESP_LOGW("dsc_diagnostic", "1. Power to DSC panel (should be 12V on keybus)");
            ESP_LOGW("dsc_diagnostic", "2. Physical wiring: Yellow→GPIO18, Green→GPIO19, Black→GND");
            ESP_LOGW("dsc_diagnostic", "3. Resistors: 33kΩ on Clock and Data lines");
            ESP_LOGW("dsc_diagnostic", "4. Panel series type: Classic vs PowerSeries");
          } else {
            ESP_LOGI("dsc_diagnostic", "DSC panel communication is working correctly!");
          }
          ESP_LOGI("dsc_diagnostic", "================================");

button:
  # System restart for diagnostic purposes
  - platform: restart
    name: "DSC System Restart"
    id: restart_switch

# ALARM CONTROL PANEL
alarm_control_panel:
  - platform: dsc_keybus
    partition: 1
    name: "DSC Partition 1 (Diagnostic)"
    id: partition_1_panel